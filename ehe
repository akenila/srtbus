def end_chrome_portable(chrome_portable_path):
    """End all ChromePortable processes matching the specified path."""
    chrome_portable_path = os.path.normpath(chrome_portable_path.lower())
    terminated_count = 0
    
    for proc in psutil.process_iter(['pid', 'name', 'exe']):
        try:
            # Check if it's a Chrome process
            if proc.info['name'] and 'chrome' in proc.info['name'].lower():
                # Get the full path of the executable
                if proc.info['exe'] and os.path.normpath(proc.info['exe'].lower()).startswith(chrome_portable_path):
                    print(f"Terminating ChromePortable process: {proc.info['pid']} - {proc.info['exe']}")
                    proc.terminate()
                    terminated_count += 1
        except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):
            pass
    
    print(f"Terminated {terminated_count} ChromePortable processes")

def split_chrome_profile_path(full_path):
    if not full_path:
        return None, None
        
    user_data_index = full_path.find("profile")
    if user_data_index == -1:
        return full_path, "Default"
    
    user_data_dir = full_path[:user_data_index + len("profile")]
    
    remaining = full_path[user_data_index + len("profile"):]
    if remaining.startswith("\\") or remaining.startswith("/"):
        remaining = remaining[1:]
    
    profile_name = remaining if remaining else "Default"
    
    if "\\" in profile_name or "/" in profile_name:
        profile_name = profile_name.split("\\")[0].split("/")[0]
    
    return user_data_dir, profile_name

# Hàm chọn thư mục chứa file SRT
def select_srt_folder(entry):
    folder_path = filedialog.askdirectory()
    if folder_path:
        entry.delete(0, tk.END)
        entry.insert(0, folder_path)

# Hàm chọn file SRT
def select_srt_file(entry):
    file_path = filedialog.askopenfilename(filetypes=[("SRT files", "*.srt")])
    if file_path:
        entry.delete(0, tk.END)
        entry.insert(0, file_path)

# Hàm chọn thư mục lưu file

def select_output_folder(entry):
    folder_path = filedialog.askdirectory()
    if folder_path:
        entry.delete(0, tk.END)
        entry.insert(0, folder_path)

# Hàm chọn file profile nếu API là Gemini
def select_profile_file(entry):
    file_path = filedialog.askopenfilename(filetypes=[("JSON files", "*.json")])
    if file_path:
        entry.delete(0, tk.END)
        entry.insert(0, file_path)

# Hàm lưu cài đặt custom
custom_settings = {}

def save_custom_settings(model_var, mapping_text, prompt_text, api_key=None, profile_path=None):
    try:
        selected_model = model_var.get()
        if not selected_model:
            messagebox.showerror("Error", "Please select a model.")
            return

        mapping = {}
        for line in mapping_text.splitlines():
            if ":" in line:
                key, value = line.split(":", 1)
                mapping[key.strip()] = value.strip()

        global custom_settings
        custom_settings = {
            "model": selected_model,
            "mapping": mapping,
            "prompt": prompt_text.strip(),
            "api_key": api_key,
            "profile_path": profile_path
        }
        messagebox.showinfo("Success", "Settings saved successfully!")
    except Exception as e:
        messagebox.showerror("Error", f"Failed to save settings: {e}")
def get_section_for_model(model_name):
    """
    Xác định section name dựa vào model name
    """
    model_name_lower = model_name.strip().lower()
    
    # Mapping model name to section
    if any(name in model_name_lower for name in ["gemini 2.5", "gemini-2.5"]):
        return "GEMINI 2.5"
    elif any(name in model_name_lower for name in ["gemini 2.0", "gemini-2.0"]):
        return "GEMINI 2.0"
    elif "gemma" in model_name_lower:
        return "GEMMA"
    else:
        return "OTHER"

def select_model(driver, model_name=None, section_name=None):
    from selenium.webdriver.common.by import By
    from selenium.webdriver.support.ui import WebDriverWait
    from selenium.webdriver.support import expected_conditions as EC

    wait = WebDriverWait(driver, 20)
    wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, ".mat-mdc-select-panel")))
    
    # Nếu chỉ có model_name mà không có section_name thì tự xác định section dựa vào model
    if model_name and not section_name:
        section_name = get_section_for_model(model_name)
        print(f"Tự động xác định section: {section_name} cho model: {model_name}")
    
    # Chọn section
    if section_name:
        # Xác định xpath đề mục dựa trên tên section
        section_xpath = None
        if section_name.strip().lower() == "gemini 2.5":
            section_xpath = '//*[@id="mat-select-1-panel"]/div/div[1]/div[1]'
        elif section_name.strip().lower() == "gemini 2.0":
            section_xpath = '//*[@id="mat-select-1-panel"]/div/div[1]/div[2]'
        else:
            # fallback: tìm theo text nếu không phải 2 đề mục trên
            sidebar_sections = driver.find_elements(By.CSS_SELECTOR, ".mat-mdc-select-panel .mat-mdc-optgroup-label")
            for section in sidebar_sections:
                if section.text.strip().lower() == section_name.strip().lower():
                    driver.execute_script("arguments[0].scrollIntoView({block: 'center'});", section)
                    section.click()
                    break
            else:
                raise Exception(f"Không tìm thấy đề mục: {section_name}")
        if section_xpath:
            section_elem = wait.until(EC.element_to_be_clickable((By.XPATH, section_xpath)))
            driver.execute_script("arguments[0].scrollIntoView({block: 'center'});", section_elem)
            section_elem.click()

    # Nếu có model_name thì chọn model trong đề mục đó
    if model_name:
        time.sleep(1)
        # Chọn model theo span có class "model-name" và đúng text
        xpath = f'//span[contains(@class, "model-name") and normalize-space(text())="{model_name}"]'
        try:
            model_elem = wait.until(EC.element_to_be_clickable((By.XPATH, xpath)))
            driver.execute_script("arguments[0].scrollIntoView({block: \'center\'});", model_elem)
            model_elem.click()
            return
        except Exception:
            raise Exception(f"Không tìm thấy model: {model_name}")
def send_prompt_and_extract(driver, prompt_text, max_retries=3):
    for attempt in range(max_retries):
        try:
            # Nhập prompt vào textarea
            prompt_xpath = '/html/body/app-root/ms-app/div/div/div[3]/div/span/ms-prompt-switcher/ms-chunk-editor/section/div/div/ms-zero-state/div[2]/div/footer/ms-prompt-input-wrapper/div/div/div/div[1]/ms-chunk-input/section/div/ms-text-chunk/ms-autosize-textarea/textarea'
            prompt_area = WebDriverWait(driver, 20).until(EC.visibility_of_element_located((By.XPATH, prompt_xpath)))
            prompt_area.clear()
            prompt_area.send_keys(prompt_text)
            
            # Click nút run theo span có class "label" và text "Run"
            run_btn_xpath = '//span[contains(@class, "label") and normalize-space(text())="Run"]'
            run_btn = WebDriverWait(driver, 20).until(EC.element_to_be_clickable((By.XPATH, run_btn_xpath)))
            run_btn.click()
            
            print(f"Lần thử {attempt+1}: Đã gửi prompt, đang chờ phản hồi...")
            time.sleep(5)  # Chờ một chút để AI bắt đầu phản hồi
            
            # Trích xuất văn bản từ phản hồi
            full_response, total_spans = extract_all_span_text(driver)
            
            # Kiểm tra nếu cần gửi lại do lỗi
            if full_response == "ERROR_NEED_RESEND":
                print(f"Lần thử {attempt+1} gặp lỗi, đang thử lại...")
                time.sleep(2)  # Chờ một chút trước khi thử lại
                continue
                
            # Nếu trích xuất thành công, trả về kết quả
            return full_response, total_spans
            
        except Exception as e:
            print(f"Lỗi trong lần thử {attempt+1}: {str(e)}")
            if attempt < max_retries - 1:
                print("Đang thử lại...")
                time.sleep(3)
    
    # Nếu đã thử hết số lần mà vẫn thất bại
    return f"Không thể trích xuất phản hồi sau {max_retries} lần thử", 0

def extract_all_span_text(driver, timeout=120, stability_period=3, check_interval=1):
    wait = WebDriverWait(driver, timeout)
    
    # Đợi cho phản hồi bắt đầu hiển thị
    try:
        # Đợi cho ms-text-chunk xuất hiện (bất kỳ ms-text-chunk nào)
        wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, "ms-text-chunk")))
        print("Đã tìm thấy ms-text-chunk, đang đợi nội dung...")
    except Exception as e:
        print(f"Không tìm thấy ms-text-chunk: {str(e)}")
        return f"Lỗi khi chờ đợi phản hồi: {str(e)}", 0
    
    # Theo dõi sự ổn định của số lượng spans
    last_spans_count = 0
    stable_since = time.time()
    start_time = time.time()
    
    while time.time() - start_time < timeout:
        # Kiểm tra nếu có thông báo lỗi xuất hiện
        try:
            error_message = driver.find_element(By.CSS_SELECTOR, ".model-error")
            if "An internal error has occurred" in error_message.text:
                print("⚠️ Phát hiện lỗi nội bộ! Cần gửi lại prompt.")
                return "ERROR_NEED_RESEND", 0
        except:
            # Không tìm thấy thông báo lỗi, tiếp tục bình thường
            pass
            
        # Tìm tất cả ms-text-chunk trong phản hồi của AI
        text_chunks = driver.find_elements(By.CSS_SELECTOR, "ms-chat-message ms-text-chunk")
        
        # Nếu không tìm thấy bằng cách trên, thử cách khác
        if not text_chunks:
            # Lấy tất cả text-chunk
            all_chunks = driver.find_elements(By.CSS_SELECTOR, "ms-text-chunk")
            
            # Bỏ qua chunk đầu tiên (câu hỏi của người dùng)
            if len(all_chunks) > 1:
                text_chunks = all_chunks[1:]
            else:
                text_chunks = all_chunks
        
        full_text = ""
        current_spans_count = 0
        
        # Duyệt qua tất cả ms-text-chunk đã lọc
        for chunk in text_chunks:
            # Thử với nhiều loại selector khác nhau
            selectors = [
                "span.ng-star-inserted",
                "span",
                "p span",
                ".cmark-node span"
            ]
            
            spans = []
            for selector in selectors:
                spans = chunk.find_elements(By.CSS_SELECTOR, selector)
                if spans:
                    break
            
            # Thu thập văn bản từ mỗi span
            for span in spans:
                try:
                    span_text = span.text.strip()
                    if span_text:
                        full_text += span_text + "\n"
                        current_spans_count += 1
                except Exception as e:
                    pass
        
        # In thông tin về số lượng spans tìm thấy
        elapsed = time.time() - start_time
        print(f"[{elapsed:.1f}s] Tìm thấy {current_spans_count} spans")
        
        # Kiểm tra sự ổn định
        if current_spans_count > last_spans_count:
            # Có spans mới, cập nhật thời điểm bắt đầu ổn định
            last_spans_count = current_spans_count
            stable_since = time.time()
            print(f"Phát hiện spans mới: {current_spans_count}, đặt lại thời gian ổn định")
        elif current_spans_count > 0:
            # Kiểm tra xem đã ổn định đủ lâu chưa
            stability_time = time.time() - stable_since
            print(f"Spans ổn định trong {stability_time:.1f}s / {stability_period}s")
            
            if stability_time >= stability_period:
                print(f"Số lượng spans ổn định trong {stability_period}s, kết thúc trích xuất")
                return full_text, current_spans_count
        
        # Đợi một khoảng thời gian trước khi kiểm tra lại
        time.sleep(check_interval)
    
    # Nếu đã hết thời gian timeout mà vẫn chưa ổn định
    if last_spans_count > 0:
        # Trích xuất lần cuối
        text_chunks = driver.find_elements(By.CSS_SELECTOR, "ms-chat-message ms-text-chunk")
        if not text_chunks:
            all_chunks = driver.find_elements(By.CSS_SELECTOR, "ms-text-chunk")
            if len(all_chunks) > 1:
                text_chunks = all_chunks[1:]
            else:
                text_chunks = all_chunks
        
        full_text = ""
        final_spans_count = 0
        
        for chunk in text_chunks:
            spans = chunk.find_elements(By.CSS_SELECTOR, "span.ng-star-inserted")
            if not spans:
                spans = chunk.find_elements(By.CSS_SELECTOR, "span")
            
            for span in spans:
                try:
                    span_text = span.text.strip()
                    if span_text:
                        full_text += span_text + "\n"
                        final_spans_count += 1
                except Exception:
                    pass
        
        print(f"Đã hết thời gian chờ. Trích xuất cuối cùng: {final_spans_count} spans")
        return full_text, final_spans_count
    
    # Nếu không tìm thấy spans nào sau thời gian timeout
    error_msg = "Không tìm thấy spans nào sau khi hết thời gian chờ."
    print(error_msg)
    
    # Thử dùng phương pháp cuối cùng - lấy toàn bộ HTML của phần response
    try:
        response_html = driver.find_element(By.CSS_SELECTOR, "ms-chat-message").get_attribute('innerHTML')
        with open("response_debug.html", "w", encoding="utf-8") as f:
            f.write(response_html)
        print("Đã lưu HTML phản hồi vào file response_debug.html để debug")
    except Exception as e:
        print(f"Không thể lưu HTML để debug: {str(e)}")
    
    return error_msg, 0

# Đợi và lấy nội dung tất cả span từ ms-text-chunk



def get_ai_studio_response(prompt, model_name, profile_path=None, driver=None):
    should_quit_driver = False
    if driver is None:
        should_quit_driver = True
        print("Khởi tạo trình duyệt Chrome...")
        
        # Sử dụng profile_path và chrome_binary_path được truyền vào hoặc giá trị mặc định
        default_profile_path = profile_path
        default_chrome_binary = "./ChromePortable/App/Chrome-bin/chrome.exe"
        
        profile_path = profile_path or default_profile_path
        chrome_binary = default_chrome_binary
        
        # Tạo profile path
        user_data_dir, profile_name = split_chrome_profile_path(profile_path)
        
        # Cấu hình Chrome
        chrome_options = uc.ChromeOptions()
        chrome_options.add_argument(f"--user-data-dir={user_data_dir}")
        chrome_options.add_argument(f"--profile-directory={profile_name}")
        chrome_options.add_argument("--no-sandbox")
        chrome_options.add_argument("--disable-dev-shm-usage")
        chrome_options.add_argument("--enable-logging")
        chrome_options.add_argument("--v=1")
        chrome_options.add_argument("--ignore-certificate-errors")
        chrome_options.binary_location = chrome_binary
        
        # Khởi tạo driver
        driver = uc.Chrome(
            options=chrome_options,
            version_main=127
        )
        
        # Mở Google AI Studio
        driver.get("https://aistudio.google.com/prompts/new_chat")
        time.sleep(5)  # Đợi trang tải xong
        
        # Đợi overlay biến mất nếu có
        try:
            WebDriverWait(driver, 20).until(EC.invisibility_of_element_located((By.CSS_SELECTOR, ".cdk-overlay-backdrop")))
        except Exception:
            pass
    
    try:
        # Mở menu chọn model
        try:
            element = WebDriverWait(driver, 20).until(EC.element_to_be_clickable((By.XPATH, '//*[@id="mat-select-value-1"]/span')))
            element.click()
        except Exception as e:
            print(f"Không thể mở menu chọn model: {str(e)}")
            
        # Chọn model
        print(f"Đang chọn model: {model_name}")
        select_model(driver, model_name=model_name)
        
        # Gửi prompt và nhận phản hồi
        print(f"Đang gửi prompt: {prompt[:50]}...")
        response_text, spans_count = send_prompt_and_extract(driver, prompt)
        
        return response_text, spans_count
        
    finally:
        # Đóng driver nếu được tạo mới trong hàm này
        if should_quit_driver:
            print("Đóng trình duyệt...")
            driver.quit()
# Hàm lưu cài đặt vào file JSON
def save_settings_to_file():
    try:
        with open("mapping_settings.json", "w", encoding="utf-8") as f:
            json.dump(custom_settings, f, ensure_ascii=False, indent=4)
        messagebox.showinfo("Success", "Settings saved to mapping_settings.json")
    except Exception as e:
        messagebox.showerror("Error", f"Failed to save settings: {e}")

# Hàm tải cài đặt từ file JSON
def load_settings_from_file():
    global custom_settings
    try:
        with open("mapping_settings.json", "r", encoding="utf-8") as f:
            custom_settings = json.load(f)
    except FileNotFoundError:
        custom_settings = {}
    except Exception as e:
        messagebox.showerror("Error", f"Failed to load settings: {e}")

# Hàm xử lý nội dung file output giống SoDong.py
# def process_output_file(output_path):
#     try:
#         # Đọc nội dung file output
#         with open(output_path, 'r', encoding='utf-8') as f:
#             content_output = f.read()

#         # Xóa ký tự không mong muốn
#         pattern_remove = r'[\[\]「」【】|│》《『⌈√←™˙\*゜・·･⭑.।০、∴∵¨ひ✓€८キ#♡♥★☆$Θ®Ⓡ◎④③②①△▲◆▶�☑■●•১הוהוו〝`´י’‘~_“”"!]+'
#         content_output = re.sub(pattern_remove, '', content_output)

#         # Cắt bỏ phần thừa bên trên hoặc dưới của file output
#         pattern_block = re.compile(
#             r'(\d+\s*\n'                           # Số thứ tự
#             r'\d{2}:\d{2}:\d{2},\d{3}\s-->\s'   # Thời gian bắt đầu
#             r'\d{2}:\d{2}:\d{2},\d{3}\s*\n'     # Thời gian kết thúc
#             r'(?:.*(?:\n|$))+?)',                    # Nội dung (có thể nhiều dòng)
#             re.MULTILINE
#         )
#         match_out = pattern_block.search(content_output)
#         if match_out:
#             matches_out = list(pattern_block.finditer(content_output))
#             content_output = content_output[matches_out[0].start():matches_out[-1].end()]

#         # Lưu lại file output sau khi làm sạch
#         with open(output_path, 'w', encoding='utf-8') as f:
#             f.write(content_output)

#     except Exception as e:
#         print(f"Error processing output file: {e}")

# Hàm dịch file (chạy trong luồng riêng)
def translate_file_thread(api_key, input_path, output_folder, translate_button, profile_path, api_type, perplexity_category=None, cookies=None, model=None):
    try:
        translate_button.config(text="Translating...")
        translate_button.config(state="disabled")
        
        # Kiểm tra nếu đầu vào là thư mục hay file
        if os.path.isdir(input_path):
            # Xử lý khi đầu vào là thư mục
            srt_files = [os.path.join(input_path, f) for f in os.listdir(input_path) 
                       if f.lower().endswith('.srt')]
            if not srt_files:
                messagebox.showinfo("Information", "No SRT files found in the selected folder.")
                return
                
            total_files = len(srt_files)
            processed_files = 0
            
            for input_file in srt_files:
                # Cập nhật trạng thái
                file_name = os.path.basename(input_file)
                translate_button.config(text=f"Translating {processed_files+1}/{total_files}: {file_name}")
                root = translate_button.winfo_toplevel()
                root.update_idletasks()
                
                # Dịch từng file

                translate_single_file(api_key, input_file, output_folder, profile_path, api_type, perplexity_category = perplexity_category, cookies = cookies, model=model)
                processed_files += 1
                
            messagebox.showinfo("Success", f"Translation completed for {processed_files} files.")
        else:
            # Xử lý khi đầu vào là file đơn
            translate_single_file(api_key, input_path, output_folder, profile_path, api_type, perplexity_category = perplexity_category, cookies = cookies, model=model)
            
    except Exception as e:
        messagebox.showerror("Error", f"Failed to translate: {e}")
    finally:
        translate_button.config(text="Translate")
        translate_button.config(state="normal")

def parse_srt_from_content(content):
    """Parse SRT content to extract subtitle components"""
    pattern = re.compile(
        r'(\d+)\s*\n'                           # Subtitle number
        r'(\d{2}:\d{2}:\d{2},\d{3})\s-->\s'     # Start time
        r'(\d{2}:\d{2}:\d{2},\d{3})\s*\n'       # End time
        r'((?:.*(?:\n|$))+?)'                   # Content (possibly multi-line)
        r'(?=\n\d+\s*\n|\Z)',                   # End of block (next subtitle or end of file)
        re.MULTILINE
    )
    
    subtitles = []
    for match in pattern.finditer(content):
        index = match.group(1)
        start = match.group(2)
        end = match.group(3)
        text = match.group(4).strip()
        subtitles.append((index, start, end, text))
    return subtitles

def process_output_file(output_path, original_path=None, retry_count=0, max_retries=6):

    try:
        # Create log file if it doesn't exist
        log_file = "translation_log.txt"
        if not os.path.exists(log_file):
            with open(log_file, 'a', encoding='utf-8') as f:
                f.write("Translation log started...\n\n")
        
        # Log processing start
        with open(log_file, 'a', encoding='utf-8') as f:
            f.write(f"Processing file: {output_path}\n")
            
        # Read the output file content
        with open(output_path, 'r', encoding='utf-8') as f:
            content_output = f.read()

        # Remove unwanted characters
        pattern_remove = r'[\[\]「」【】|│》《『⌈√←™˙\*゜・·･⭑.。০、∴∵¨ひ✓€८キ#♡♥★☆$Θ®Ⓡ◎④③②①△▲◆▶�☑■●•১הוהוו〝`´י''~_"""!]+'
        content_output = re.sub(pattern_remove, '', content_output)
            
        # Trim excess content (keep only valid SRT blocks)
        pattern_block = re.compile(
            r'(\d+\s*\n'                           # Subtitle number
            r'\d{2}:\d{2}:\d{2},\d{3}\s-->\s'      # Start time
            r'\d{2}:\d{2}:\d{2},\d{3}\s*\n'        # End time
            r'(?:.*(?:\n|$))+?)',                  # Content (possibly multi-line)
            re.MULTILINE
        )
        
        # Find all subtitle blocks
        match_out = pattern_block.search(content_output)
        if match_out:
            matches_out = list(pattern_block.finditer(content_output))
            content_output = content_output[matches_out[0].start():matches_out[-1].end()]
        
        # Count Chinese characters after cleaning
        count_chinese = len(re.findall(r'[\u4e00-\u9fff]', content_output))
        
        # Count parentheses pairs after cleaning
        matches_parentheses = re.findall(r'\([^)]*\)', content_output)
        count_parentheses = len(matches_parentheses)
        
        # Log the statistics
        with open(log_file, 'a', encoding='utf-8') as f:
            f.write(f"- Chinese characters: {count_chinese}\n")
            f.write(f"- Parentheses pairs: {count_parentheses}\n")
        
        print(f"Processed file: {output_path}")
        print(f"- Chinese characters: {count_chinese}")
        print(f"- Parentheses pairs: {count_parentheses}")
        
        # Parse the cleaned content
        subtitles_target = parse_srt_from_content(content_output)
        
        # Check issues and determine if retry is needed
        needs_retry = False
        retry_reason = ""
        
        # If we have an original file to compare with
        if original_path and os.path.exists(original_path):
            with open(original_path, 'r', encoding='utf-8') as f:
                content_original = f.read()
                
            # Clean the original content too
            content_original = re.sub(pattern_remove, '', content_original)
            match_orig = pattern_block.search(content_original)
            if match_orig:
                matches_orig = list(pattern_block.finditer(content_original))
                content_original = content_original[matches_orig[0].start():matches_orig[-1].end()]
                
            # Parse the original content
            subtitles_original = parse_srt_from_content(content_original)
            
            # Check 1: Line count mismatch
            if len(subtitles_original) != len(subtitles_target):
                needs_retry = True
                retry_reason = f"Line count mismatch: original={len(subtitles_original)}, translated={len(subtitles_target)}"
                with open(log_file, 'a', encoding='utf-8') as f:
                    f.write(f"- {retry_reason}\n")
        
        # Check 2: Too many Chinese characters
        if count_chinese > 30:
            needs_retry = True
            retry_reason = f"Too many Chinese characters: {count_chinese} (limit: 30)"
            with open(log_file, 'a', encoding='utf-8') as f:
                f.write(f"- {retry_reason}\n")
        
        # Check 3: Too many parentheses
        if count_parentheses > 20:
            needs_retry = True
            retry_reason = f"Too many parentheses pairs: {count_parentheses} (limit: 20)"
            with open(log_file, 'a', encoding='utf-8') as f:
                f.write(f"- {retry_reason}\n")
        
        # If retry is needed and we haven't reached max retries
        if needs_retry:
            if retry_count < max_retries:
                with open(log_file, 'a', encoding='utf-8') as f:
                    f.write(f"- Needs retry ({retry_count + 1}/{max_retries}): {retry_reason}\n\n")
                return False, True, retry_reason, retry_reason
            else:
                with open(log_file, 'a', encoding='utf-8') as f:
                    f.write(f"- Maximum retries reached. Last issue: {retry_reason}\n\n")
                return False, False, f"Maximum retries reached. Last issue: {retry_reason}", retry_reason
        
        # If no retry needed, save the formatted content
        with open(output_path, 'w', encoding='utf-8') as f:
            formatted_content = ''
            for sub in subtitles_target:
                formatted_content += f"{sub[0]}\n{sub[1]} --> {sub[2]}\n{sub[3]}\n\n"
            f.write(formatted_content)
        
        with open(log_file, 'a', encoding='utf-8') as f:
            f.write("- File processed successfully\n\n")
        
        return True, False, "File processed successfully", None
            
    except Exception as e:
        print(f"Error processing output file: {e}")
        traceback.print_exc()
        with open("translation_log.txt", 'a', encoding='utf-8') as f:
            f.write(f"- Error: {str(e)}\n\n")
        return False, False, f"Error: {str(e)}", str(e)
# Function to translate file
def end_chrome_portable(chrome_portable_path):
    """End all ChromePortable processes matching the specified path."""
    chrome_portable_path = os.path.normpath(chrome_portable_path.lower())
    terminated_count = 0
    
    for proc in psutil.process_iter(['pid', 'name', 'exe']):
        try:
            # Check if it's a Chrome process
            if proc.info['name'] and 'chrome' in proc.info['name'].lower():
                # Get the full path of the executable
                if proc.info['exe'] and os.path.normpath(proc.info['exe'].lower()).startswith(chrome_portable_path):
                    print(f"Terminating ChromePortable process: {proc.info['pid']} - {proc.info['exe']}")
                    proc.terminate()
                    terminated_count += 1
        except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):
            pass
    
    print(f"Terminated {terminated_count} ChromePortable processes")
# Hàm dịch một file đơn lẻ
def translate_single_file(api_key, input_file, output_folder, profile_path, api_type, retry_count=0, max_retries=6, perplexity_category=None, cookies=None, model=None):
    try:
        file_name = os.path.basename(input_file)
        target_lang = "en"  # Default language
        for key, lang in custom_settings.get("mapping", {}).items():
            if key in file_name:
                target_lang = lang
                break

        with open(input_file, "r", encoding="utf-8") as f:
            content = f.read()
        prompt = f"{target_lang}:\n\n{content}"
        
        if custom_settings.get("prompt"):
            prompt = custom_settings["prompt"].replace("{content}", content).replace("{target_lang}", target_lang)
            
        if api_type == "AI Studio":
            # AI Studio API logic
            if model is None:
                    model = custom_settings.get("model", "gemini-1.5-flash")
            response_text, spans_count = get_ai_studio_response(prompt, model_name=model, profile_path=profile_path)
            translated_text = response_text
            

        elif api_type == "Gemini":
            # Use Gemini Web API similar to test.py
            try:
                # Initialize selenium to get cookies
                user_data_dir, profile_name = split_chrome_profile_path(profile_path)
                if not user_data_dir or not profile_name:
                    raise Exception("Invalid profile path format")
                
                chrome_options = Options()
                chrome_options.add_argument(f"user-data-dir={user_data_dir}")
                chrome_options.add_argument(f"--profile-directory={profile_name}")
                chrome_options.binary_location = "./ChromePortable/App/Chrome-bin/chrome.exe"
                
                service = Service(ChromeDriverManager(driver_version="127.0.6533.120").install())
                driver = webdriver.Chrome(service=service, options=chrome_options)
                
                driver.get("https://gemini.google.com")
                time.sleep(10)  # Wait for the page to load
                
                cookies = driver.get_cookies()
                secure_1psid = None
                secure_1psidts = None
                
                for cookie in cookies:
                    if cookie['name'] == '__Secure-1PSID':
                        secure_1psid = cookie['value']
                    elif cookie['name'] == '__Secure-1PSIDTS':
                        secure_1psidts = cookie['value']
                
                driver.quit()
                
                if not secure_1psid or not secure_1psidts:
                    raise Exception("Required cookies not found. Please check your Chrome profile.")
                
                # Use the async function with asyncio
                
                # Create an async function to use GeminiClient
                if model is None:
                    model = custom_settings.get("model", "gemini-1.5-flash")
                async def translate_with_gemini():
                    try:
                        client = GeminiClient(secure_1psid, secure_1psidts)
                        await client.init(timeout=400)
                        response = await client.generate_content(prompt=prompt, model=model )
                        translated_text = response.text
                        await client.close()
                        return translated_text
                    except Exception as e:
                        await client.close()
                        raise e
                
                # Run the async function
                translated_text = asyncio.run(translate_with_gemini())
                
            except Exception as e:
                raise Exception(f"Gemini API error: {str(e)}")

        elif api_type == "ChatGPT":
            # Use UnlimitedGPT for ChatGPT API
            try:
                api = ChatGPT(chrome_profile=profile_path, session_token="")
                message = api.send_message(prompt, input_mode="INSTANT", input_delay=0.1, close_after_response=True)
                translated_text = message.response
                end_chrome_portable(f"{os.getcwd()}/ChromePortable/App/Chrome-bin/chrome.exe")
                time.sleep(2)  # Wait for Chrome to close properly
            except Exception as e:
                raise Exception(f"ChatGPT API error: {str(e)}")
            
        elif api_type == "Perplexity":
            cookies_json = cookies
            if model is None:
                model = custom_settings.get("model", None)
            if perplexity_category is None:
                perplexity_category = custom_settings.get("perplexity_category", "auto")
            if not cookies_json:
                raise Exception("Perplexity cookies are required.")
            
            # Try to parse the cookies as JSON
            try:
                perplexity_cookies = {cookie['name']: cookie['value'] for cookie in json.loads(cookies_json)}
            except json.JSONDecodeError:
                # If not valid JSON, try to parse as key-value pairs
                perplexity_cookies = {}
                for line in cookies_json.split('\n'):
                    if ':' in line:
                        key, value = line.split(':', 1)
                        perplexity_cookies[key.strip()] = value.strip()
            
            perplexity_cli = perplexity.Client(perplexity_cookies)
            print(custom_settings["perplexity_category"], custom_settings["model"])
            if custom_settings["model"]==None:
                resp = perplexity_cli.search(prompt, mode=perplexity_category, sources=['web'],language='en-US', follow_up=None, incognito=False)
            else:
                resp = perplexity_cli.search(prompt, mode=perplexity_category, sources=['web'],language='en-US', follow_up=None, incognito=False, model=model)
            for i in resp["text"]:
                if i["step_type"] == "FINAL":
                    translated_text = json.loads(i["content"]["answer"])["answer"]

        else:
            raise Exception("Invalid API type selected.")

        output_file = os.path.join(output_folder, file_name)
        output_file = output_file.replace(".srt", f" Copy.srt")
        with open(output_file, "w", encoding="utf-8") as f:
            f.write(translated_text)

        # Xử lý nội dung file output
        success, needs_retry, message, retry_reason = process_output_file(output_file, input_file, retry_count, max_retries)
        
        if needs_retry and retry_count < max_retries:
            # Wait a moment before retrying
            time.sleep(3)
            # Recursive call for retry
            return translate_single_file(api_key, input_file, output_folder, profile_path, api_type, retry_count + 1, model=model)
        else:
            return output_file
        

    except Exception as e:
        raise Exception(f"Failed to translate {os.path.basename(input_file)}: {e}")
def save_all_settings(api_var, input_file_entry, output_folder_entry, api_key_entry, profile_entry, model_var, mapping_text):
    """Save all settings from UI into JSON file"""
    try:
        global custom_settings
        
        # Get API type
        api_type = api_var.get()
        
        # Process mapping text
        mapping = {}
        for line in mapping_text.get("1.0", tk.END).splitlines():
            if ":" in line:
                key, value = line.split(":", 1)
                mapping[key.strip()] = value.strip()
        
        # Save all settings in dictionary
        custom_settings = {
            "api_type": api_type,
            "input_path": input_file_entry.get(),
            "output_folder": output_folder_entry.get(),
            "api_key": api_key_entry.get(),
            "profile_path": profile_entry.get(),
            "model": model_var.get(),
            "mapping": mapping
        }
        
        # Save to file
        with open("subsrt_settings.json", "w", encoding="utf-8") as f:
            json.dump(custom_settings, f, ensure_ascii=False, indent=4)
            
        messagebox.showinfo("Success", "All settings saved successfully!")
        return True
    except Exception as e:
        messagebox.showerror("Error", f"Failed to save settings: {e}")
        return False
    
def load_settings_from_file():
    global custom_settings
    try:
        with open("subsrt_settings.json", "r", encoding="utf-8") as f:
            custom_settings = json.load(f)
        return True
    except FileNotFoundError:
        custom_settings = {}
        return False
    except Exception as e:
        messagebox.showerror("Error", f"Failed to load settings: {e}")
        return False
# Giao diện chính

def main():
    root = tk.Tk()
    root.title("SRT Translator")

    # API selection
    tk.Label(root, text="Select API:").grid(row=0, column=0, padx=5, pady=5, sticky="w")
    api_var = ttk.Combobox(root, values=["AI Studio", "Gemini", "ChatGPT", "Perplexity"])
    api_var.grid(row=0, column=1, padx=5, pady=5)

    # Input file or folder
    tk.Label(root, text="Input SRT File or Folder:").grid(row=1, column=0, padx=5, pady=5, sticky="w")
    input_file_entry = tk.Entry(root, width=50)
    input_file_entry.grid(row=1, column=1, padx=5, pady=5)
    input_browse_frame = tk.Frame(root)
    input_browse_frame.grid(row=1, column=2, padx=5, pady=5)
    tk.Button(input_browse_frame, text="File", command=lambda: select_srt_file(input_file_entry)).grid(row=0, column=0, padx=2)
    tk.Button(input_browse_frame, text="Folder", command=lambda: select_srt_folder(input_file_entry)).grid(row=0, column=1, padx=2)

    # Output folder
    tk.Label(root, text="Output Folder:").grid(row=2, column=0, padx=5, pady=5, sticky="w")
    output_folder_entry = tk.Entry(root, width=50)
    output_folder_entry.grid(row=2, column=1, padx=5, pady=5)
    tk.Button(root, text="Browse", command=lambda: select_output_folder(output_folder_entry)).grid(row=2, column=2, padx=5, pady=5)

    # API key and profile path fields
    api_key_label = tk.Label(root, text="API Key:")
    api_key_label.grid(row=3, column=0, padx=5, pady=5, sticky="w")
    api_key_entry = tk.Entry(root, width=50, show="*")
    api_key_entry.grid(row=3, column=1, padx=5, pady=5)

    profile_label = tk.Label(root, text="Profile Path:")
    profile_entry = tk.Entry(root, width=50)
    profile_button = tk.Button(root, text="Browse", command=lambda: select_profile_file(profile_entry))

    cookies_label = tk.Label(root, text="Perplexity Cookies:")
    cookies_text = tk.Text(root, height=4, width=50)

    # Model selection
    tk.Label(root, text="Select Model:").grid(row=4, column=0, padx=5, pady=5, sticky="w")
    model_var = ttk.Combobox(root, width=50)
    model_var.grid(row=4, column=1, padx=5, pady=5)

    # Perplexity category selection (initially hidden)
    perplexity_category_label = tk.Label(root, text="Perplexity Category:")
    perplexity_category_var = ttk.Combobox(root, width=50, 
                                          values=["auto", "pro", "reasoning", "deep research"])
    
    # Define the perplexity models mapping
    perplexity_models = {
        'auto': ['None'],
        'pro': ['None', 'sonar', 'gpt-4.5', 'gpt-4o', 'claude 3.7 sonnet', 'gemini 2.0 flash', 'grok-2'],
        'reasoning': ['None', 'r1', 'o3-mini', 'claude 3.7 sonnet'],
        'deep research': ['None']
    }
    
    def update_perplexity_models(event=None):
        """Update the model dropdown based on the selected Perplexity category"""
        selected_category = perplexity_category_var.get()
        if selected_category in perplexity_models:
            model_var.config(values=perplexity_models[selected_category])
            model_var.current(0)
    
    perplexity_category_var.bind("<<ComboboxSelected>>", update_perplexity_models)

    def update_api_fields(event=None):
        """Update UI fields based on selected API"""
        selected_api = api_var.get()
        
        # Handle API key and profile fields
        if selected_api == "Gemini" or selected_api == "ChatGPT":
            api_key_label.grid_remove()
            api_key_entry.grid_remove()
            cookies_label.grid_remove()
            cookies_text.grid_remove()
            profile_label.grid(row=3, column=0, padx=5, pady=5, sticky="w")
            profile_entry.grid(row=3, column=1, padx=5, pady=5)
            profile_button.grid(row=3, column=2, padx=5, pady=5)
        elif selected_api == "Perplexity":
            # For Perplexity, show cookies input instead of profile path or API key
            api_key_label.grid_remove()
            api_key_entry.grid_remove()
            profile_label.grid_remove()
            profile_entry.grid_remove()
            profile_button.grid_remove()
            cookies_label.grid(row=3, column=0, padx=5, pady=5, sticky="w")
            cookies_text.grid(row=3, column=1, padx=5, pady=5, columnspan=2, sticky="we")
        else:
            profile_label.grid_remove()
            profile_entry.grid_remove()
            profile_button.grid_remove()
            api_key_label.grid(row=3, column=0, padx=5, pady=5, sticky="w")
            api_key_entry.grid(row=3, column=1, padx=5, pady=5)
        
        # Update model dropdown based on API
        if selected_api == "ChatGPT":
            model_var.config(values=["default"])
            model_var.current(0)
            perplexity_category_label.grid_remove()
            perplexity_category_var.grid_remove()
        elif selected_api == "Gemini":
            model_var.config(values=["unspecified", "gemini-2.0-flash", "gemini-2.0-flash-thinking", 
                                     "gemini-2.5-flash", "gemini-2.5-pro"])
            if model_var.get() not in model_var["values"]:
                model_var.current(0)
            perplexity_category_label.grid_remove()
            perplexity_category_var.grid_remove()
        elif selected_api == "AI Studio":
            model_var.config(values=["Gemini 2.0 Flash", 
                             "Gemini 2.0 Flash Preview Image Generation", "Gemini 2.0 Flash-Lite",
                             "Gemini 2.5 Pro", "Gemini 2.5 Pro Preview 05-06", "Gemini 2.5 Flash",
                             "Gemini 2.5 Flash Preview 04-17", "Gemini 2.5 Flash-Lite Preview 06-17"])
            api_key_label.grid_remove()
            api_key_entry.grid_remove()
            cookies_label.grid_remove()
            cookies_text.grid_remove()
            profile_label.grid(row=3, column=0, padx=5, pady=5, sticky="w")
            profile_entry.grid(row=3, column=1, padx=5, pady=5)
            profile_button.grid(row=3, column=2, padx=5, pady=5)
        elif selected_api == "Perplexity":
            # Show Perplexity category dropdown
            perplexity_category_label.grid(row=5, column=0, padx=5, pady=5, sticky="w")
            perplexity_category_var.grid(row=5, column=1, padx=5, pady=5)
            if not perplexity_category_var.get():
                perplexity_category_var.current(0)
            # Initial update of models based on default category
            update_perplexity_models()
            
            # Move mapping text down one row when Perplexity is selected
            mapping_label.grid(row=6, column=0, padx=5, pady=5, sticky="nw")
            mapping_text.grid(row=6, column=1, padx=5, pady=5)
            button_frame.grid(row=8, column=0, columnspan=3, padx=5, pady=10)
        else:
            perplexity_category_label.grid_remove()
            perplexity_category_var.grid_remove()
            
            # Move mapping text back to original position for other APIs
            mapping_label.grid(row=5, column=0, padx=5, pady=5, sticky="nw")
            mapping_text.grid(row=5, column=1, padx=5, pady=5)
            button_frame.grid(row=7, column=0, columnspan=3, padx=5, pady=10)

    api_var.bind("<<ComboboxSelected>>", update_api_fields)

    # Custom mapping
    mapping_label = tk.Label(root, text="Custom Language Mapping (e.g., rvTBN:es):")
    mapping_label.grid(row=5, column=0, padx=5, pady=5, sticky="nw")
    mapping_text = tk.Text(root, height=5, width=50)
    mapping_text.grid(row=5, column=1, padx=5, pady=5)

    # Button frame
    button_frame = tk.Frame(root)
    button_frame.grid(row=7, column=0, columnspan=3, padx=5, pady=10)
    
    # Save settings button
    save_button = tk.Button(
        button_frame, 
        text="Save All Settings", 
        command=lambda: save_all_settings(
            api_var, 
            input_file_entry, 
            output_folder_entry, 
            api_key_entry, 
            profile_entry, 
            model_var, 
            mapping_text,
            perplexity_category_var if api_var.get() == "Perplexity" else None
        ),
        width=15,
        height=2
    )
    save_button.pack(side=tk.LEFT, padx=10)

    # Translate button
    translate_button = tk.Button(
        button_frame, 
        text="Translate", 
        command=lambda: threading.Thread(
            target=translate_file_thread, 
            args=(
                api_key_entry.get(), 
                input_file_entry.get(), 
                output_folder_entry.get(), 
                translate_button, 
                profile_entry.get(), 
                api_var.get(),
                perplexity_category_var.get() if api_var.get() == "Perplexity" else None,
                cookies_text.get("1.0", tk.END).strip() if api_var.get() == "Perplexity" else None,
                model_var.get()
            )
        ).start(),
        width=15,
        height=2
    )
    translate_button.pack(side=tk.RIGHT, padx=10)

    # Update the save_all_settings function to include Perplexity category
    def save_all_settings(api_var, input_file_entry, output_folder_entry, api_key_entry, 
                         profile_entry, model_var, mapping_text, perplexity_category_var=None):
        """Save all settings from UI into JSON file"""
        try:
            global custom_settings
            
            # Get API type
            api_type = api_var.get()
            
            # Process mapping text
            mapping = {}
            for line in mapping_text.get("1.0", tk.END).splitlines():
                if ":" in line:
                    key, value = line.split(":", 1)
                    mapping[key.strip()] = value.strip()
            
            # Save all settings in dictionary
            custom_settings = {
                "api_type": api_type,
                "input_path": input_file_entry.get(),
                "output_folder": output_folder_entry.get(),
                "api_key": api_key_entry.get(),
                "profile_path": profile_entry.get(),
                "model": model_var.get(),
                "mapping": mapping
            }
            
            # Add Perplexity category if applicable
            if api_type == "Perplexity" and perplexity_category_var:
                custom_settings["perplexity_category"] = perplexity_category_var.get()
                custom_settings["perplexity_cookies"] = cookies_text.get("1.0", tk.END).strip()
            
            # Save to file
            with open("subsrt_settings.json", "w", encoding="utf-8") as f:
                json.dump(custom_settings, f, ensure_ascii=False, indent=4)
                
            messagebox.showinfo("Success", "All settings saved successfully!")
            return True
        except Exception as e:
            messagebox.showerror("Error", f"Failed to save settings: {e}")
            return False

    # Load settings when starting
    if load_settings_from_file():
        if "api_type" in custom_settings:
            api_var.set(custom_settings.get("api_type", ""))
            
        if "input_path" in custom_settings:
            input_file_entry.insert(0, custom_settings.get("input_path", ""))
            
        if "output_folder" in custom_settings:
            output_folder_entry.insert(0, custom_settings.get("output_folder", ""))
            
        if "model" in custom_settings:
            model_var.set(custom_settings.get("model", ""))
            
        if "mapping" in custom_settings:
            mapping_text.delete("1.0", tk.END)
            for key, value in custom_settings.get("mapping", {}).items():
                mapping_text.insert(tk.END, f"{key}:{value}\n")
                
        if "api_key" in custom_settings:
            api_key_entry.insert(0, custom_settings.get("api_key", ""))
            
        if "profile_path" in custom_settings:
            profile_entry.insert(0, custom_settings.get("profile_path", ""))
            
        if "perplexity_category" in custom_settings:
            perplexity_category_var.set(custom_settings.get("perplexity_category", ""))
        if "perplexity_cookies" in custom_settings:
            cookies_text.delete("1.0", tk.END)
            cookies_text.insert(tk.END, custom_settings.get("perplexity_cookies", ""))
        
        # Trigger the API field update to configure the UI properly
        update_api_fields()

    root.mainloop()

if __name__ == "__main__":
    main()
