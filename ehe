def split_chrome_profile_path(full_path):
    if not full_path:
        return None, None
        
    user_data_index = full_path.find("User Data")
    if user_data_index == -1:
        return full_path, "Default"
    
    user_data_dir = full_path[:user_data_index + len("User Data")]
    
    remaining = full_path[user_data_index + len("User Data"):]
    if remaining.startswith("\\") or remaining.startswith("/"):
        remaining = remaining[1:]
    
    profile_name = remaining if remaining else "Default"
    
    if "\\" in profile_name or "/" in profile_name:
        profile_name = profile_name.split("\\")[0].split("/")[0]
    
    return user_data_dir, profile_name

# Hàm chọn thư mục chứa file SRT
def select_srt_folder(entry):
    folder_path = filedialog.askdirectory()
    if folder_path:
        entry.delete(0, tk.END)
        entry.insert(0, folder_path)

# Hàm chọn file SRT
def select_srt_file(entry):
    file_path = filedialog.askopenfilename(filetypes=[("SRT files", "*.srt")])
    if file_path:
        entry.delete(0, tk.END)
        entry.insert(0, file_path)

# Hàm chọn thư mục lưu file

def select_output_folder(entry):
    folder_path = filedialog.askdirectory()
    if folder_path:
        entry.delete(0, tk.END)
        entry.insert(0, folder_path)

# Hàm chọn file profile nếu API là Gemini
def select_profile_file(entry):
    file_path = filedialog.askopenfilename(filetypes=[("JSON files", "*.json")])
    if file_path:
        entry.delete(0, tk.END)
        entry.insert(0, file_path)

# Hàm lưu cài đặt custom
custom_settings = {}

def save_custom_settings(model_var, mapping_text, prompt_text, api_key=None, profile_path=None):
    try:
        selected_model = model_var.get()
        if not selected_model:
            messagebox.showerror("Error", "Please select a model.")
            return

        mapping = {}
        for line in mapping_text.splitlines():
            if ":" in line:
                key, value = line.split(":", 1)
                mapping[key.strip()] = value.strip()

        global custom_settings
        custom_settings = {
            "model": selected_model,
            "mapping": mapping,
            "prompt": prompt_text.strip(),
            "api_key": api_key,
            "profile_path": profile_path
        }
        messagebox.showinfo("Success", "Settings saved successfully!")
    except Exception as e:
        messagebox.showerror("Error", f"Failed to save settings: {e}")

# Hàm lưu cài đặt vào file JSON
def save_settings_to_file():
    try:
        with open("mapping_settings.json", "w", encoding="utf-8") as f:
            json.dump(custom_settings, f, ensure_ascii=False, indent=4)
        messagebox.showinfo("Success", "Settings saved to mapping_settings.json")
    except Exception as e:
        messagebox.showerror("Error", f"Failed to save settings: {e}")

# Hàm tải cài đặt từ file JSON
def load_settings_from_file():
    global custom_settings
    try:
        with open("mapping_settings.json", "r", encoding="utf-8") as f:
            custom_settings = json.load(f)
    except FileNotFoundError:
        custom_settings = {}
    except Exception as e:
        messagebox.showerror("Error", f"Failed to load settings: {e}")

# Hàm xử lý nội dung file output giống SoDong.py
def process_output_file(output_path):
    try:
        # Đọc nội dung file output
        with open(output_path, 'r', encoding='utf-8') as f:
            content_output = f.read()

        # Xóa ký tự không mong muốn
        pattern_remove = r'[\[\]「」【】|│》《『⌈√←™˙\*゜・·･⭑.।০、∴∵¨ひ✓€८キ#♡♥★☆$Θ®Ⓡ◎④③②①△▲◆▶�☑■●•১הוהוו〝`´י’‘~_“”"!]+'
        content_output = re.sub(pattern_remove, '', content_output)

        # Cắt bỏ phần thừa bên trên hoặc dưới của file output
        pattern_block = re.compile(
            r'(\d+\s*\n'                           # Số thứ tự
            r'\d{2}:\d{2}:\d{2},\d{3}\s-->\s'   # Thời gian bắt đầu
            r'\d{2}:\d{2}:\d{2},\d{3}\s*\n'     # Thời gian kết thúc
            r'(?:.*(?:\n|$))+?)',                    # Nội dung (có thể nhiều dòng)
            re.MULTILINE
        )
        match_out = pattern_block.search(content_output)
        if match_out:
            matches_out = list(pattern_block.finditer(content_output))
            content_output = content_output[matches_out[0].start():matches_out[-1].end()]

        # Lưu lại file output sau khi làm sạch
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(content_output)

    except Exception as e:
        print(f"Error processing output file: {e}")

# Hàm dịch file (chạy trong luồng riêng)
def translate_file_thread(api_key, input_path, output_folder, translate_button, profile_path, api_type):
    try:
        translate_button.config(text="Translating...")
        translate_button.config(state="disabled")
        
        # Kiểm tra nếu đầu vào là thư mục hay file
        if os.path.isdir(input_path):
            # Xử lý khi đầu vào là thư mục
            srt_files = [os.path.join(input_path, f) for f in os.listdir(input_path) 
                       if f.lower().endswith('.srt')]
            if not srt_files:
                messagebox.showinfo("Information", "No SRT files found in the selected folder.")
                return
                
            total_files = len(srt_files)
            processed_files = 0
            
            for input_file in srt_files:
                # Cập nhật trạng thái
                file_name = os.path.basename(input_file)
                translate_button.config(text=f"Translating {processed_files+1}/{total_files}: {file_name}")
                root = translate_button.winfo_toplevel()
                root.update_idletasks()
                
                # Dịch từng file
                translate_single_file(api_key, input_file, output_folder, profile_path, api_type)
                processed_files += 1
                
            messagebox.showinfo("Success", f"Translation completed for {processed_files} files.")
        else:
            # Xử lý khi đầu vào là file đơn
            translate_single_file(api_key, input_path, output_folder, profile_path, api_type)
            
    except Exception as e:
        messagebox.showerror("Error", f"Failed to translate: {e}")
    finally:
        translate_button.config(text="Translate")
        translate_button.config(state="normal")

# Hàm dịch một file đơn lẻ
def translate_single_file(api_key, input_file, output_folder, profile_path, api_type):
    try:
        file_name = os.path.basename(input_file)
        target_lang = "en"  # Default language
        for key, lang in custom_settings.get("mapping", {}).items():
            if key in file_name:
                target_lang = lang
                break

        with open(input_file, "r", encoding="utf-8") as f:
            content = f.read()
        prompt = f"Translate the following text to {target_lang}:\n\n{content}"
        
        if custom_settings.get("prompt"):
            prompt = custom_settings["prompt"].replace("{content}", content).replace("{target_lang}", target_lang)
            
        if api_type == "AI Studio":
            # AI Studio API logic
            url = f"https://generativelanguage.googleapis.com/v1beta/models/{custom_settings['model']}:generateContent?key={api_key}"
            headers = {"Content-Type": "application/json"}
            payload = {
                "contents": [
                    {
                        "parts": [
                            {"text": prompt}
                        ]
                    }
                ]
            }

            response = requests.post(url, json=payload, headers=headers)

            if response.status_code == 200:
                response_data = response.json()
                translated_text = response_data["candidates"][0]["content"]["parts"][0]["text"]
            else:
                raise Exception(f"API Error: {response.status_code}, {response.text}")

        elif api_type == "Gemini":
            # Use Gemini Web API similar to test.py
            try:
                # Initialize selenium to get cookies
                user_data_dir, profile_name = split_chrome_profile_path(profile_path)
                if not user_data_dir or not profile_name:
                    raise Exception("Invalid profile path format")
                
                chrome_options = Options()
                chrome_options.add_argument(f"user-data-dir={user_data_dir}")
                chrome_options.add_argument(f"--profile-directory={profile_name}")
                chrome_options.add_argument("--headless")
                
                service = Service(ChromeDriverManager().install())
                driver = webdriver.Chrome(service=service, options=chrome_options)
                
                driver.get("https://gemini.google.com")
                time.sleep(10)  # Wait for the page to load
                
                cookies = driver.get_cookies()
                secure_1psid = None
                secure_1psidts = None
                
                for cookie in cookies:
                    if cookie['name'] == '__Secure-1PSID':
                        secure_1psid = cookie['value']
                    elif cookie['name'] == '__Secure-1PSIDTS':
                        secure_1psidts = cookie['value']
                
                driver.quit()
                
                if not secure_1psid or not secure_1psidts:
                    raise Exception("Required cookies not found. Please check your Chrome profile.")
                
                # Use the async function with asyncio
                
                # Create an async function to use GeminiClient
                async def translate_with_gemini():
                    try:
                        client = GeminiClient(secure_1psid, secure_1psidts)
                        await client.init(timeout=30)
                        response = await client.generate_content(prompt=prompt, model=custom_settings['model'])
                        translated_text = response.text
                        await client.close()
                        return translated_text
                    except Exception as e:
                        await client.close()
                        raise e
                
                # Run the async function
                translated_text = asyncio.run(translate_with_gemini())
                
            except Exception as e:
                raise Exception(f"Gemini API error: {str(e)}")

        else:
            raise Exception("Invalid API type selected.")

        output_file = os.path.join(output_folder, file_name)
        output_file = output_file.replace(".srt", f"_{target_lang}.srt")
        with open(output_file, "w", encoding="utf-8") as f:
            f.write(translated_text)

        # Xử lý nội dung file output
        process_output_file(output_file)
        
        return output_file

    except Exception as e:
        raise Exception(f"Failed to translate {os.path.basename(input_file)}: {e}")

# Giao diện chính

def main():
    root = tk.Tk()
    root.title("SRT Translator")

    # API selection
    tk.Label(root, text="Select API:").grid(row=0, column=0, padx=5, pady=5, sticky="w")
    api_var = ttk.Combobox(root, values=["AI Studio", "Gemini"])
    api_var.grid(row=0, column=1, padx=5, pady=5)

    # Input file or folder
    tk.Label(root, text="Input SRT File or Folder:").grid(row=1, column=0, padx=5, pady=5, sticky="w")
    input_file_entry = tk.Entry(root, width=50)
    input_file_entry.grid(row=1, column=1, padx=5, pady=5)
    input_browse_frame = tk.Frame(root)
    input_browse_frame.grid(row=1, column=2, padx=5, pady=5)
    tk.Button(input_browse_frame, text="File", command=lambda: select_srt_file(input_file_entry)).grid(row=0, column=0, padx=2)
    tk.Button(input_browse_frame, text="Folder", command=lambda: select_srt_folder(input_file_entry)).grid(row=0, column=1, padx=2)

    # Output folder
    tk.Label(root, text="Output Folder:").grid(row=2, column=0, padx=5, pady=5, sticky="w")
    output_folder_entry = tk.Entry(root, width=50)
    output_folder_entry.grid(row=2, column=1, padx=5, pady=5)
    tk.Button(root, text="Browse", command=lambda: select_output_folder(output_folder_entry)).grid(row=2, column=2, padx=5, pady=5)

    # API key and profile path fields
    api_key_label = tk.Label(root, text="API Key:")
    api_key_label.grid(row=3, column=0, padx=5, pady=5, sticky="w")
    api_key_entry = tk.Entry(root, width=50, show="*")
    api_key_entry.grid(row=3, column=1, padx=5, pady=5)

    profile_label = tk.Label(root, text="Profile Path:")
    profile_entry = tk.Entry(root, width=50)
    profile_button = tk.Button(root, text="Browse", command=lambda: select_profile_file(profile_entry))

    def update_api_fields(event):
        if api_var.get() == "Gemini":
            api_key_label.grid_remove()
            api_key_entry.grid_remove()
            profile_label.grid(row=3, column=0, padx=5, pady=5, sticky="w")
            profile_entry.grid(row=3, column=1, padx=5, pady=5)
            profile_button.grid(row=3, column=2, padx=5, pady=5)
        else:
            profile_label.grid_remove()
            profile_entry.grid_remove()
            profile_button.grid_remove()
            api_key_label.grid(row=3, column=0, padx=5, pady=5, sticky="w")
            api_key_entry.grid(row=3, column=1, padx=5, pady=5)

    api_var.bind("<<ComboboxSelected>>", update_api_fields)

    # Model selection
    tk.Label(root, text="Select Model:").grid(row=4, column=0, padx=5, pady=5, sticky="w")
    model_var = ttk.Combobox(root, width=50, values=["gemini-2.0-flash", "gemini-2.0-flash-thinking", "gemini-2.0-flash-lite", "gemini-1.5-flash", "gemini-2.0-flash-thinking-exp-01-21"])
    model_var.grid(row=4, column=1, padx=5, pady=5)

    # Custom mapping
    tk.Label(root, text="Custom Language Mapping (e.g., rvTBN:es):").grid(row=5, column=0, padx=5, pady=5, sticky="nw")
    mapping_text = tk.Text(root, height=5, width=50)
    mapping_text.grid(row=5, column=1, padx=5, pady=5)

    # Nút lưu cài đặt
    tk.Button(root, text="Save Settings", command=lambda: [save_custom_settings(model_var, mapping_text.get("1.0", tk.END), "", api_key_entry.get(), profile_entry.get()), save_settings_to_file()]).grid(row=6, column=1, padx=5, pady=10, sticky="e")

    # Translate button
    translate_button = tk.Button(root, text="Translate", command=lambda: threading.Thread(target=translate_file_thread, args=(api_key_entry.get(), input_file_entry.get(), output_folder_entry.get(), translate_button, profile_entry.get(), api_var.get())).start())
    translate_button.grid(row=7, column=1, padx=5, pady=10, sticky="e")

    # Tải cài đặt khi khởi động
    load_settings_from_file()
    if custom_settings:
        model_var.set(custom_settings.get("model", ""))
        mapping_text.delete("1.0", tk.END)
        for key, value in custom_settings.get("mapping", {}).items():
            mapping_text.insert(tk.END, f"{key}:{value}\n")
        api_key_entry.insert(0, custom_settings.get("api_key", ""))
        profile_entry.insert(0, custom_settings.get("profile_path", ""))

    root.mainloop()

if __name__ == "__main__":
    main()
